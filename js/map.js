
//######################################################################################################################
//########################## MAIN PROGRAM ##############################################################################
//######################################################################################################################
{

    var loaderBackground = document.createElement("div");

    loaderBackground.classList.add("loaderBackground");

    var loaderDiv = document.createElement("div");

    loaderDiv.classList.add("loader");

    loaderBackground.appendChild(loaderDiv);

    document.body.insertBefore(loaderBackground, document.body.firstChild);

    var xobj = new XMLHttpRequest();

    xobj.open('GET', 'JSON/fusionPlaces.geojson', true);

    xobj.onreadystatechange = function () {

        if (xobj.readyState === 4 && xobj.status == "200") {

            document.body.removeChild(loaderBackground);

            geojsonSource = xobj.responseText;

            init();

        }

    };

    xobj.send(null);

}
//######################################################################################################################

//######################################################################################################################
//######################## GLOBAL VARIABLES ############################################################################
//######################################################################################################################

var accentMap = {
    'á':'a', 'é':'e', 'í':'i','ó':'o','ú':'u', 'ä' : 'a', 'à' : 'a', 'è' : 'e', 'ï' : 'i', 'ô' : 'o', 'ö' : 'o', '\'' : ' ', ' ' : ' ', '-' : ' '
};

function accent_fold (s) {

    if (!s) { return ''; }
    var ret = '';
    for (var i = 0; i < s.length; i++) {
        ret += accentMap[s.charAt(i)] || s.charAt(i);
    }
    return ret;

};

var googlePlacesAPIService; // Service for API request executions

var userCoordinates;        // User's coordinates

var map;                    // The map generated by mapbox

var latVariance = 0.001764; // Latitude difference to get to an other sector // Base = 0.000882

var lngVariance = 0.002560; // Longitude difference to get to an other sector // Base = 0.001280

var geojsonSource;

var forcedDate = null;

var mapGridBounds = {

    topLatitude : 45.788347,

    bottomLatitude : 45.732777,

    leftLongitute : 4.791173,

    rightLongitude : 4.871854

};

var popups = [];

//######################################################################################################################


//######################################################################################################################
//########## GENERAL INITIALISATION AND MAP INITIALISATION #############################################################
//######################################################################################################################

var userPositionMarker;     // Marker associated with user's location

//----------------------------------------------------------------------------------------------------------------------

function init() {

    // Initialisation of user's location with coordinates of Lyon near Bellecour

    userCoordinates = {

        userLatitude: 45.75717800533178,

        userLongitude: 4.83480298193669

    };

    // Mapbox generation with API key authentication

    map = mapInitialisation(userCoordinates);

    map.on('click', function (element) {

        var features = map.queryRenderedFeatures(element.point, {

            layers: ['placesSymbols']

        });

        if (!features.length) {

            return;

        }

        var feature = features[0];

        if( feature.properties['place_id'] != null ) {

            popups.push(createPopupForSymbol(feature));

        }

    });

    var popup = new mapboxgl.Popup();

    map.on('mouseenter', 'placesSymbols', function (element) {

        var features = map.queryRenderedFeatures(element.point, {

            layers: ['placesSymbols']

        });

        if (!features.length) {

            return;

        }

        var feature = features[0];

        // For some strange reason, a cluster is considered as a placesSymbol's feature, this test assure not.

        //console.log(feature.properties);

        if( feature.properties['place_id'] != null ) {

            popup = createPopupForSymbol(feature);

        }

    });

    map.on('mouseleave', 'placesSymbols', function() {

        popup.remove();

    });

    var goButton = document.getElementById("go");

    goButton.addEventListener("click", filterMap);

    var resetButton = document.getElementById("resetFilters");

    resetButton.addEventListener("click", resetFilter);

    var searchTextfield = document.getElementById("textSearch");

    searchTextfield.addEventListener("input", function () {

        filterSearch(searchTextfield.value);

    });

}

//----------------------------------------------------------------------------------------------------------------------

function mapInitialisation(userCoordinates) {

    mapboxgl.accessToken = 'pk.eyJ1IjoiYWd0ZXJyYWwiLCJhIjoiY2pkMjRnbjJkNWYwZDJ4bGdwMWlxODJiYSJ9.4W9g-Go5vHpL9UZmjnGj4g';

    map = new mapboxgl.Map({

        container: 'map',

        center: [userCoordinates.userLongitude, userCoordinates.userLatitude],

        zoom: 15,

        style: 'mapbox://styles/mapbox/basic-v9'

    });

    map.addControl(new mapboxgl.GeolocateControl({

        positionOptions: {

            enableHighAccuracy: true

        },

        trackUserLocation: true

    }), 'bottom-right');

    // disable map rotation using right click + drag
    map.dragRotate.disable();

    // disable map rotation using touch rotation gesture
    map.touchZoomRotate.disableRotation();

    map.on('load', function () {

        map.addSource("places", {
            type: "geojson",
            data: "JSON/fusionPlaces.geojson",
            cluster: true,
            clusterMaxZoom: 16, // Max zoom to cluster points on
            clusterRadius: 75 // Radius of each cluster when clustering points (defaults to 50)
        });

        map.loadImage('Assets/homeIcon.png', function (error, image) {

            map.addImage('homeIcon', image);

        });

        map.addLayer({
            id: "placesSymbols",
            type: "symbol",
            source: "places",
            layout: {
                "text-field": "{name}",
                "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                "text-offset": [0, 0.6],
                "text-anchor": "top",
                "icon-image": "homeIcon",
                "icon-size": 0.05,
                "visibility": 'visible',
                "icon-allow-overlap": true,
                "text-allow-overlap": true

            },
            paint: {
                "text-halo-color": "rgba(0,0,0,1)"
            }
        });

       /* map.addLayer({
            id: "placesSymbols",
            type: "circle",
            source: "places",
            paint: {
                "circle-color":
                    "#51bbd6"
                ,
                "circle-radius":
                    5
            }
        });
*/
        map.addLayer({
            id: "clusters",
            type: "circle",
            source: "places",
            filter: ["has", "point_count"],
            paint: {
                "circle-color": [
                    "step",
                    ["get", "point_count"],
                    "#51bbd6",
                    100,
                    "#e9f154",
                    750,
                    "#f25525"
                ],
                "circle-radius": [
                    "step",
                    ["get", "point_count"],
                    20,
                    100,
                    30,
                    750,
                    40
                ]
            }
        });

        map.addLayer({
            id: "cluster-count",
            type: "symbol",
            source: "places",
            filter: ["has", "point_count"],
            layout: {
                "text-field": "{point_count_abbreviated}",
                "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
                "text-size": 12
            }
        });

    });


    // Update user's location

    getUserLocation();

    // Creation of user marker on map

    userPositionMarker = new mapboxgl.Marker().setLngLat([userCoordinates.userLongitude, userCoordinates.userLatitude]);

    var markerHeight = 50, markerRadius = 10, linearOffset = 25;

    var popupOffsets = {
        'top': [0, 0],
        'top-left': [0, 0],
        'top-right': [0, 0],
        'bottom': [0, -markerHeight],
        'bottom-left': [linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
        'bottom-right': [-linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
        'left': [markerRadius, (markerHeight - markerRadius) * -1],
        'right': [-markerRadius, (markerHeight - markerRadius) * -1]
    };

    var popup = new mapboxgl.Popup({offset: popupOffsets, closeButton: false})
        .setLngLat([userCoordinates.userLongitude, userCoordinates.userLatitude])
        .setHTML("<h3 id='youAreHere' >You are here</h3>")
        .addTo(map);

    userPositionMarker.setPopup(popup);

    userPositionMarker.addTo(map);

    var location = new mapboxgl.LngLat(userCoordinates.userLongitude, userCoordinates.userLatitude);

    var coords = {

        latitude: location.lat,

        longitude: location.lng

    };

    var pos = {

        coords: coords

    };

    setUserCoordinates(pos);

    googlePlacesAPIService = new google.maps.places.PlacesService(document.createElement('div'));

    return map;

}

//----------------------------------------------------------------------------------------------------------------------

function getUserLocation() {

    map.setCenter([userCoordinates.userLongitude, userCoordinates.userLatitude]);

    if (navigator.geolocation) {

        navigator.geolocation.watchPosition(setUserCoordinates);

    }

}

//----------------------------------------------------------------------------------------------------------------------

function setUserCoordinates(position) {

    userCoordinates.userLatitude = position.coords.latitude;

    userCoordinates.userLongitude = position.coords.longitude;

    userPositionMarker.setLngLat([userCoordinates.userLongitude, userCoordinates.userLatitude]);

}


//######################################################################################################################
//##################### DISPLAY RELATED METHODS ########################################################################
//######################################################################################################################

function createPopupForSymbol(feature) {

    var placeInformations = feature.properties;

    var markerHeight = 50, markerRadius = 10, linearOffset = 25;

    var popupOffsets = {
        'top': [0, 0],
        'top-left': [0, 0],
        'top-right': [0, 0],
        'bottom': [0, -markerHeight],
        'bottom-left': [linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
        'bottom-right': [-linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
        'left': [markerRadius, (markerHeight - markerRadius) * -1],
        'right': [-markerRadius, (markerHeight - markerRadius) * -1]
    };

    var popup = new mapboxgl.Popup({offset: popupOffsets})
        .setLngLat(feature.geometry.coordinates)
        .setHTML(createMarkerPopupHTML(placeInformations))
        .addTo(map);

    return popup;

}

//----------------------------------------------------------------------------------------------------------------------

function createMarkerPopupHTML(place) {

    var html = "";

    var placeName = accent_fold(place.name);

    html += "<p id='popupTitle'>" + placeName + "</p>";

    html += "<p id='popupType'>" + place.mainType + "</p>";

    if (place.rating != null) {

        console.log("rating=" + place.rating);

        html += "<p id='popupRating'>";

        var i;

        for (i = 0; i < place.rating; i++) {

            /* add full stars */
            html += "<i class=\"fa fa-star\"></i>";

        }

        for (var j = i; j < 5; j++) {

            /* add empty stars */
            html += "<i class=\"fa fa-star-o\"></i>";

        }

        html += "</p>";
    }

    html += "<br><p id='popupAddress'><i class='fa fa-street-view'></i><a target='_blank' href='https://www.google.com/maps/dir/?api=1&origin=" + userCoordinates.userLatitude + ',' + userCoordinates.userLongitude + "&destination=QVB&destination_place_id=" + place['place_id'] + "&travelmode=walking'>" + place['formatted_address'] + "</a></p>";

    if (place.website != null) {

        html += "<br><p id='popupWebsite'><i class='fa fa-at'></i><a target=\"_blank\" href=\"" + place.website + "\">Website</a></p>";

    }

    if (place['formatted_phone_number'] != null) {

        html += "<br><p id='popupPhone'><i class='fa fa-phone'></i><a href=\"tel:" + place['formatted_phone_number'] + "\">" + place['formatted_phone_number'] + "</a></p>";

    }

    if (place.weekday_text != null) {

        var days = JSON.parse(place.weekday_text);

        if (days != null) {

            html += "<br><p id='popupWeekday'>";

            var d = new Date();

            var day = d.getDay();

            if( forcedDate != null ) {

                day = forcedDate;

            }

            //In JavaScript, the first day of the week (0) means Sunday
            // getDay()			days[]
            // 0 Sunday			Monday
            // 1 Monday			Tuesday
            // 2 Tuesday		Wednesday
            // 3 Wednesday		Thursday
            // 4 Thursday		Friday
            // 5 Friday			Saturday
            // 6 Saturday		Sunday

            var str = days[day];

            if (day === 0) {

                str = days[6];

            } else {

                str = days[day - 1];

                if( forcedDate == null ) {

                    //str.indexOf( ': ' )+2 => starts after ': '
                    html += "<p class='day'><i class='fa fa-clock-o'></i>Today: " + str.substring(str.indexOf(': ') + 2, str.length) + "</p><br>";

                } else {

                    //str.indexOf( ': ' )+2 => starts after ': '
                    html += "<p class='day'><i class='fa fa-clock-o'></i>" + str + "</p>\n";

                }

            }

        }

    }

    if ( place.price != null ) {



    }

    if ( place.subtypes != null ) {

    	var subtypesToDisplay = JSON.parse(place.subtypes);

    	for (var i = 0 ; i < subtypesToDisplay.length ; i++) {

    	    var idColorR1 = Math.floor((Math.random() * 16));
    	    var idColorR2 = Math.floor((Math.random() * 16));

    	    var idColorG1 = Math.floor((Math.random() * 16));
    	    var idColorG2 = Math.floor((Math.random() * 16));

    	    var idColorB1 = Math.floor((Math.random() * 16));
    	    var idColorB2 = Math.floor((Math.random() * 16));


    	    var tabColors = [idColorR1, idColorR2, idColorG1, idColorG2, idColorB1,  idColorB2];

    	    var colors = "";

    	    html += "<button type='button' class='btn btn-sm' id='subtypes'+i+''>" + subtypesToDisplay[i].title + "</button>";


    	    for (var j = 0 ; j < tabColors.length ; j++) {

    	        switch(tabColors[j]) {

    	            case 10: {

    	                tabColors[j] = "A";

    	                break;

    	            }

    	            case 11: {

    	                tabColors[j] = "B";

    	                break;

    	            }

    	            case 12: {

    	                tabColors[j] = "C";

    	                break;

    	            }

    	            case 13: {

    	                tabColors[j] = "D";

    	                break;

    	            }

    	            case 14: {

    	                tabColors[j] = "E";

    	                break;

    	            }

    	            case 15: {

    	                tabColors[j] = "F";

    	                break;

    	            }

    	            default: {

    	                tabColors[j] = "0";

    	                break;

    	            }

    	        }

    	        colors += tabColors[j];

    	    }

    	    console.log(colors);

    	    $("#subtypes"+i).css('background-color', ''+colors, '!important');

    	}

    }

    return html;

}

//----------------------------------------------------------------------------------------------------------------------

function showMap(err, data) {
    // The geocoder can return an area, like a city, or a
    // point, like an address. Here we handle both cases,
    // by fitting the map bounds to an area or zooming to a point.
    if (data.lbounds) {

        map.fitBounds(data.lbounds);

    } else if (data.latlng) {

        map.setView([data.latlng[0], data.latlng[1]], 13);

    }
}


//######################################################################################################################
//############ FILTER ACTIONS ON MAP ###################################################################################
//######################################################################################################################

function filterMap() {


    resetFilter();

    var restaurantButton = document.getElementById("restaurantButton");

    var barButton = document.getElementById("barButton");

    var barRestaurantButton = document.getElementById("barRestaurantButton");


    var typeButtons = [restaurantButton, barButton, barRestaurantButton];

    var priceButton1 = document.getElementById("priceButton1");

    var priceButton2 = document.getElementById("priceButton2");

    var priceButton3 = document.getElementById("priceButton3");

    var priceButton4 = document.getElementById("priceButton4");


    var priceButtons = [priceButton1, priceButton2, priceButton3, priceButton4];


    var starButton1 = document.getElementById("starButton1");

    var starButton2 = document.getElementById("starButton2");

    var starButton3 = document.getElementById("starButton3");

    var starButton4 = document.getElementById("starButton4");

    var starButton5 = document.getElementById("starButton5");


    var starButtons = [starButton1, starButton2, starButton3, starButton4, starButton5];


    var aroundMeButton = document.getElementById("aroundMe");

    var openedNowButton = document.getElementById("openedNow");

    var openingHoursInput = document.getElementById("inputTime");


    var filter = {

        filteringTypes : false,

        types: [false, false, false],

        price: null,

        rating: null,

        aroundMe: false,

        opened: false,

        openingHours: null

    };

    //~ console.log(filter);

    var i;

    for (i = 0; i < typeButtons.length; i++) {

        var clicked = $(typeButtons[i]).data().clicked;

        filter.types[i] = clicked;

        if( clicked ) {

            filter.filteringTypes = true;

        }

    }


    for (i = 1; i < priceButtons.length && $(priceButtons[i]).data().clicked; i++) {

        filter.price = i + 1;

    }


    for (i = 1; i < starButtons.length && $(starButtons[i]).data().clicked; i++) {

        filter.rating = i + 1;

    }

    filter.aroundMe = aroundMeButton.checked;

    filter.opened = openedNowButton.checked;

    if ( openingHoursInput.value.length !== 0 ) {

        filter.openingHours = openingHoursInput.value;

    }

    //~console.log(filter);

    filterFunction(filter);

}

//----------------------------------------------------------------------------------------------------------------------

function filterFunction(filter) {

    var filteredGeojson = JSON.parse(geojsonSource);

    var features = filteredGeojson.features;

    if( filter.filteringTypes ) {

        features = filteredGeojson.features.filter(function (value) {

            var values = ['Restaurant', 'Bar', 'Bar-restaurant'];

            var bool = false;

            for (var i = 0; i < filter.types.length; i++) {

                if (filter.types[i] == true) {

                    bool = bool || value.properties.type == values[i];

                }

            }

            return bool;

        });

    }

    if( filter.rating != null ){

        features = features.filter( function (value) {

            return value.properties.rating == filter.rating;

        });

    }

    if( filter.aroundMe ) {

        map.flyTo({center : [userCoordinates.userLongitude, userCoordinates.userLatitude]});

        features = features.filter( function (value) {

            return ( value.properties.latitude <= userCoordinates.userLatitude + 2*latVariance
                && value.properties.latitude >= userCoordinates.userLatitude - 2*latVariance
                && value.properties.longitude <= userCoordinates.userLongitude + 2*lngVariance
                && value.properties.longitude >= userCoordinates.userLongitude - 2*lngVariance);

        });

    }

    if( filter.opened ) {

        features = features.filter( function (value) {

            if( value.properties.weekday_text != null ) {

                var date = new Date();

                var day = date.getDay();

                var openingHours = value.properties.weekday_text[day];

                if (day === 0) {

                    openingHours = value.properties.weekday_text[6];

                } else {

                    openingHours = value.properties.weekday_text[day - 1];

                }


                return openenedFilter( openingHours );

            } else {

                return false;

            }

        });

    }

    if ( filter.openingHours !== null ) {
        var str = document.getElementById("inputTime").value;

        var hour = str.substring(0, str.length - str.indexOf(':')-1);

        var minute = str.substring(str.indexOf(':')+1, str.length);

        /* get the field "openingHours" from the variable filter */
        if( filter.openingHours ) {

            features = filteredGeojson.features.filter(function (value) {

                var values = [hour];

                var bool = false;

                for (var i = 0; i < filter.openingHours.length; i++) {

                    if (filter.openingHours[i] === hour) {

                        bool = bool || value.properties.openingHours === hour;

                    }

                }

                console.log("return is applied..;");

                return bool;

            });

        }

        console.log("filter is applied...");

    }

    if( filter.price != null ) {

        features = features.filter( function (value) {

            if( value.price != null ) {

                return value.price == filter.price;

            } else {

                return false;

            }

        });

    }

    filteredGeojson.features = features;

    map.getSource('places').setData(filteredGeojson);

    if ( filteredGeojson.features.length == 1 ) {

        map.flyTo({center : filteredGeojson.features[0].geometry.coordinates});

    }

}

function openenedFilter(openingHours) {

    var hourRegex = new RegExp(/((([1-9])|(1[0-2])):([0-5])(0|5)((\s(a|p)m)))/);

    var separatorRegex = new RegExp(/ . /);

    var twoHoursRegex = new RegExp(/,/);

    var closedRegex = new RegExp(/Closed/);

    if( openingHours.search(closedRegex) == -1 ) {

        var current = moment();

        var endFirstPart = openingHours.search(twoHoursRegex);

        var hourDeb = openingHours.search( hourRegex );

        var hourEnd = openingHours.search( separatorRegex );

        var firstHour = openingHours.substring( hourDeb, hourEnd );

        var secondPart = openingHours.substring( hourEnd, openingHours.length );

        var secondHourDeb = secondPart.search( hourRegex );

        var secondHour = secondPart.substring( secondHourDeb, openingHours.length );

        var first = moment(firstHour, 'HH:mm a');

        var second = moment(secondHour, 'HH:mm a');

        if( endFirstPart == -1) {

            return current.isBetween(first, second);

        } else {

            var afterHours = openingHours.substring(endFirstPart, openingHours.length);

            var firstHour = afterHours.substring( hourDeb, hourEnd );

            var secondPart = afterHours.substring( hourEnd, openingHours.length );

            var secondHourDeb = secondPart.search( hourRegex );

            var secondHour = secondPart.substring( secondHourDeb, openingHours.length );

            var secondFirst = moment(firstHour, 'HH:mm a');

            var secondSecond = moment(secondHour, 'HH:mm a');

            return current.isBetween(first, second) || current.isBetween(secondFirst, secondSecond);

        }

    } else {

        return false;

    }

}

function filterDate(filter) {

    var str = document.getElementById("#inputTime").value;

    var hour = str.substring(0, str.length - str.indexOf(':')-1);

    var minute = str.substring(str.indexOf(':')+1, str.length);


    var filteredGeojson = JSON.parse(geojsonSource);

    var features = filteredGeojson.features;

    if( filter.filteringTypes ) {

        features = filteredGeojson.features.filter(function (value) {

            var values = [hour];

            var bool = false;

            for (var i = 0; i < filter.types.length; i++) {

                if (filter.types[i] == true) {

                    bool = bool || value.properties.type == values[i];

                }

            }

            return bool;

        });

    }

}

//----------------------------------------------------------------------------------------------------------------------

function resetFilter() {

    for(var i = 0; i < popups.length ; i++) {

        popups[i].remove();

    }

    forcedDate = null;

    map.getSource('places').setData(JSON.parse(geojsonSource));

}

//----------------------------------------------------------------------------------------------------------------------

function filterSearch(searchString) {

    resetFilter();

    if (searchString.length !== 0) {

        var filteredGeojson = JSON.parse(geojsonSource);

        var features = filteredGeojson.features;

        var optionRegex = new RegExp(/!/);

        if( searchString.search(optionRegex) == -1 ) {

            features = features.filter(function (value) {

                var valueName = accent_fold(value.properties.name).toLowerCase();

                var valueType = accent_fold(value.properties.type).toLowerCase();

                var valueAddress = accent_fold(value.properties.adress).toLowerCase();

                var searchName = accent_fold(searchString).toLowerCase();

                var subtype = false;

                if( value.properties.subtypes != null ) {

                    for (var l = 0  ; l < value.properties.subtypes.length; l++) {

                        var elem = value.properties.subtypes[l];

                        if( accent_fold(elem.alias).indexOf(searchName) != -1 || accent_fold(elem.title.toLowerCase()).indexOf(searchName) != -1 ) {

                            subtype = true;

                            break;

                        }

                    }

                }

                return (valueName.indexOf(searchName) != -1 || valueAddress.indexOf(searchName) != -1 || valueType.indexOf(searchName) != -1 || subtype);

            });

        } else {

            var openRegex = new RegExp(/open/);

            if( searchString.search( openRegex ) != -1 ) {

                features = features.filter( function (value) {

                    var sundayRegex = new RegExp(/sunday|dimanche/);

                    var mondayRegex = new RegExp(/monday|lundi/);

                    var tuesdayRegex = new RegExp(/tuesday|mardi/);

                    var wednesdayRegex = new RegExp(/wednesday|mercredi/);

                    var thursdayRegex = new RegExp(/thursday|jeudi/);

                    var fridayRegex = new RegExp(/friday|vendredi/);

                    var saturdayRegex = new RegExp(/saturday|samedi/);

                    var regexes = [ sundayRegex, mondayRegex, tuesdayRegex, wednesdayRegex, thursdayRegex, fridayRegex, saturdayRegex ];

                    for(var i = 0; i < regexes.length ; i++) {

                        if ( searchString.search( regexes[i] ) != -1 ) {

                            if( value.properties.weekday_text != null && i < value.properties.weekday_text.length ) {

                                forcedDate = i;

                                var openingHours = value.properties.weekday_text[ i ];

                                return openenedFilter( openingHours );

                            } else {

                                return false;

                            }

                        }

                    }

                    return false;

                });

            }

        }

        filteredGeojson.features = features;

        map.getSource('places').setData(filteredGeojson);

        if ( filteredGeojson.features.length == 1 ) {

            map.flyTo({center : filteredGeojson.features[0].geometry.coordinates});

        }

    } else {

        resetFilter();

    }

}

//######################################################################################################################
//############### DATA RETRIEVER AND JSON'S CREATION ###################################################################
//######################################################################################################################

var fetchedBars= [];

var barsString = "";

var fetchedRestaurants = [];

var restaurantsString = "";

var fetchedBarRestaurants = [];

var barsRestaurantsString = "";

var placesRequest;          // Google places API request

var counter;                // Simple counter for tasks

//----------------------------------------------------------------------------------------------------------------------

function fetchAllPlaceRadar( timeInterval ) {

    var allPlacesId = [];

    counter = 0;

    var lngStep = lngVariance * 7;

    var latStep = latVariance * 7;


    var baseBounds = {

        north: 45.788347,

        west: 4.791173,

        south: 45.788347 - latStep,

        east: 4.791173 + lngStep

    };

    var bounds = {

        north: 45.788347,

        west: 4.791173,

        south: 45.788347 - latStep,

        east: 4.791173 + lngStep

    };

    var i = 1;

    console.log( "Crawling on lyon..." );

    var interval = setInterval( function () {

        if ( bounds.north < mapGridBounds.bottomLatitude - latVariance ) {

            console.log(JSON.stringify(allPlacesId));

            getDetailsAfterRadar( allPlacesId, 2000 );

            clearInterval( interval );

        } else {

            var sw = new google.maps.LatLng( bounds.south.toFixed( 6 ), bounds.west.toFixed( 6 ) );

            var ne = new google.maps.LatLng( bounds.north.toFixed( 6 ), bounds.east.toFixed( 6 ) );

            var radarBounds = new google.maps.LatLngBounds( sw, ne );

            placesRequest = {

                bounds : radarBounds,

                type : "bar"

            };

            googlePlacesAPIService.radarSearch( placesRequest, function ( results, status ) {

                radarSquareCallBack( results, status, allPlacesId, i );

            } );

            placesRequest = {

                bounds : radarBounds,

                type : "restaurant"

            };

            googlePlacesAPIService.radarSearch( placesRequest, function ( results, status ) {

                radarSquareCallBack( results, status, allPlacesId, i );

            } );

            // test markers
            /*~
                    console.log( bounds );

                    var position = new mapboxgl.LngLat( bounds.west.toFixed( 6 ), bounds.north.toFixed( 6 ) );

                    new  mapboxgl.Marker().setLngLat( position ).addTo( map );

                    position = new mapboxgl.LngLat( bounds.west.toFixed( 6 ), bounds.south.toFixed( 6 ) );

                    new  mapboxgl.Marker().setLngLat( position ).addTo( map );

                    position = new mapboxgl.LngLat( bounds.east.toFixed( 6 ), bounds.north.toFixed( 6 ) );

                    new  mapboxgl.Marker().setLngLat( position ).addTo( map );

                    position = new mapboxgl.LngLat( bounds.east.toFixed( 6 ), bounds.south.toFixed( 6 ) );

                    new  mapboxgl.Marker().setLngLat( position ).addTo( map );
            */

            if ( bounds.west > mapGridBounds.rightLongitude ) {

                bounds.west = baseBounds.west;

                bounds.east = bounds.west + lngStep;

                bounds.north -= latStep;

                bounds.south -= latStep;

            } else {

                bounds.west += lngStep;

                bounds.east += lngStep;

            }

            i++;

        }

    }, timeInterval );

    setTimeout( function () {

        console.log( "All data retrieved" );

    }, timeInterval * 31 + 1000 );

}

//----------------------------------------------------------------------------------------------------------------------

function radarSquareCallBack( results, status, array, i ) {

    i--;

    console.log( "Fetching zones : " + i + " / 31 ... Status : " + status );

    if ( status === google.maps.places.PlacesServiceStatus.OK ) {

        //~ console.log( results );

        for ( var i = 0 ; i < results.length ; i++ ) {

            array.push( results[i]["place_id"] );

        }

    }

    //~ console.log( array.toString() );

}

//----------------------------------------------------------------------------------------------------------------------

function getDetailsAfterRadar( placeIds, timeInterval ) {

    var i = 2464;

    var interval = setInterval( function () {

        if ( i % 100 === 0 ) {

            console.log( "Bars : " );
            console.log( fetchedBars );
            console.log( "Bar Restaurants : " );
            console.log( fetchedBarRestaurants );
            console.log( "Restaurants : " );
            console.log( fetchedRestaurants );
            console.log( "Total : " );
            console.log( fetchedBarRestaurants.length + fetchedBars.length + fetchedRestaurants.length );

        }

        if ( i >= placeIds.length ) {

            clearInterval( interval );

            for ( var j = 0 ; j < fetchedBars.length ; j ++ ) {

                barsString += JSON.stringify( fetchedBars[j] );

                if ( j !== fetchedBars.length - 1 ) {

                    barsString += ",";

                }

            }

            for ( j = 0 ; j < fetchedRestaurants.length ; j ++ ) {

                restaurantsString += JSON.stringify( fetchedRestaurants[j] );

                if ( j !== fetchedRestaurants.length - 1 ) {

                    restaurantsString += ",";

                }

            }

            for ( j = 0 ; j < fetchedBarRestaurants.length ; j ++ ) {

                barsRestaurantsString += JSON.stringify( fetchedBarRestaurants[j] );

                if ( j !== fetchedBarRestaurants.length - 1 ) {

                    barsRestaurantsString += ",";

                }

            }

            return;

        }

        var detailsRequest = {

            placeId : placeIds[i]

        };

        googlePlacesAPIService.getDetails( detailsRequest, function ( results, status ) {

            if ( status === "OVER_QUERY_LIMIT" ) {

                console.log( "State " + i + ", interruption" );

                clearInterval( interval );

                for ( var j = 0 ; j < fetchedBars.length ; j ++ ) {

                    barsString += JSON.stringify( fetchedBars[j] );

                    if ( j !== fetchedBars.length - 1 ) {

                        barsString += ",";

                    }

                }

                for ( j = 0 ; j < fetchedRestaurants.length ; j ++ ) {

                    restaurantsString += JSON.stringify( fetchedRestaurants[j] );

                    if ( j !== fetchedRestaurants.length - 1 ) {

                        restaurantsString += ",";

                    }

                }

                for ( j = 0 ; j < fetchedBarRestaurants.length ; j ++ ) {

                    barsRestaurantsString += JSON.stringify( fetchedBarRestaurants[j] );

                    if ( j !== fetchedBarRestaurants.length - 1 ) {

                        barsRestaurantsString += ",";

                    }

                }

            } else {

                getDetailsCallback( results, status, fetchedBars, fetchedRestaurants, fetchedBarRestaurants, i, placeIds.length );

            }

        } );

        i++;

    }, timeInterval );

    setTimeout( function () {

        console.log( "All details retrieved" );

    }, timeInterval * placeIds.length + 1000 );

}

//----------------------------------------------------------------------------------------------------------------------

function getDetailsCallback( result, status, bars, restaurants, barRestaurants, state , progression ) {

    state --;

    console.log( "Progression : " + state + " / " + progression + " ... Status : " + status );

    if ( status === google.maps.places.PlacesServiceStatus.OK ) {

        //~ console.log( "callback" );

        var actualPlace = result;

        var isBar = checkIfPlaceIsBar( actualPlace );

        var isRestaurant = checkIfPlaceIsRestaurant( actualPlace );

        if ( isBar && isRestaurant ) {

            actualPlace.mainType = "Bar-restaurant";

            barRestaurants.push( actualPlace );

        } else if ( isBar ) {

            actualPlace.mainType = "Bar";

            bars.push( actualPlace );

        } else if ( isRestaurant ) {

            actualPlace.mainType = "Restaurant";

            restaurants.push( actualPlace );

        }

    }

}

//----------------------------------------------------------------------------------------------------------------------

function checkIfPlaceIsBar( place ) {

    for ( var i = 0 ; i < place.types.length ; i++ )
    {

        if ( place.types[i] === "bar" ) {

            return true;

        }

    }

    return false;

}

//----------------------------------------------------------------------------------------------------------------------

function checkIfPlaceIsRestaurant( place ) {

    for ( var i = 0 ; i < place.types.length ; i++ )
    {

        if ( place.types[i] === "restaurant" ) {

            return true;

        }

    }

    return false;

}


//######################################################################################################################
//############ JSON FILES LOADER AND GEOJSON GENERATION ################################################################
//######################################################################################################################

var loadedBarsString = "";

var loadedRestaurantsString = "";

var loadedBarsRestaurantsString = "";

var numberOfJSONLoadingCallbacks = 0;

//----------------------------------------------------------------------------------------------------------------------

function loadAllJSON( callback ) {

    loadBarsJSON();

    loadRestaurantsJSON();

    loadBarsRestaurantsJSON();

}

//----------------------------------------------------------------------------------------------------------------------

function loadBarsJSON() {

    var xobj = new XMLHttpRequest();

    xobj.overrideMimeType("application/json");

    xobj.open('GET', 'JSON/bars.json', true);

    xobj.onreadystatechange = function () {

        if (xobj.readyState === 4 && xobj.status == "200") {

            loadedBarsString = xobj.responseText;

            console.log("retrieved Bars");

            callbackLoadingJSON();

        }

    };

    xobj.send(null);

}

//----------------------------------------------------------------------------------------------------------------------

function loadRestaurantsJSON() {

    var xobj = new XMLHttpRequest();

    xobj.open('GET', 'JSON/restaurants.json', true);

    xobj.onreadystatechange = function () {

        if (xobj.readyState === 4 && xobj.status == "200") {

            loadedRestaurantsString = xobj.responseText;

            console.log("retrieved Restaurants");

            callbackLoadingJSON();

        }

    };

    xobj.send(null);

}

//----------------------------------------------------------------------------------------------------------------------

function loadBarsRestaurantsJSON() {

    var xobj = new XMLHttpRequest();

    xobj.open('GET', 'JSON/barsRestaurants.json', true);

    xobj.onreadystatechange = function () {

        if (xobj.readyState === 4 && xobj.status == "200") {

            loadedBarsRestaurantsString = xobj.responseText;

            console.log("retrieved Bars-Restaurants");

            callbackLoadingJSON();

        }

    };

    xobj.send(null);

}

//----------------------------------------------------------------------------------------------------------------------

function callbackLoadingJSON() {

    numberOfJSONLoadingCallbacks++;

    if (numberOfJSONLoadingCallbacks === 3) {

        generateGeoJSON();

    }

}

//----------------------------------------------------------------------------------------------------------------------

function generateGeoJSON() {

    var parsedBars = JSON.parse(loadedBarsString);

    var parsedRestaurants = JSON.parse(loadedRestaurantsString);

    var parsedBarRestaurants = JSON.parse(loadedBarsRestaurantsString);

    var geoJSONString = "{\"type\" : \"FeatureCollection\", \"features\":[";

    var geoJSONItem = {

        "type": "Feature",

        "geometry": {

            "type": "Point",

            "coordinates": [null, null]

        },

        "properties": {

            "adress": null,

            "icon": null,

            "id": null,

            "latitude" : null,

            "longitude" : null,

            "name": null,

            "opened": null,

            "phone": null,

            "rating": null,

            "type": null,

            "types": null,

            "website": null,

            "weekday_text": null

        }

    };

    for (var i = 0; i < parsedBars.length; i++) {

        geoJSONItem.geometry.coordinates = [parsedBars[i]["coordinates"]["lng"], parsedBars[i]["coordinates"]["lat"]];

        geoJSONItem.geometry.name = parsedBars[i]["name"];

        geoJSONItem.properties.latitude = parsedBars[i]["coordinates"]["lat"];

        geoJSONItem.properties.longitude = parsedBars[i]["coordinates"]["lng"];

        geoJSONItem.properties.id = parsedBars[i].id;

        geoJSONItem.properties.name = parsedBars[i].name;

        geoJSONItem.properties.type = parsedBars[i].type;

        geoJSONItem.properties.types = parsedBars[i].types;

        geoJSONItem.properties.adress = parsedBars[i].adress;

        geoJSONItem.properties.rating = Math.floor(parsedBars[i].rating);

        geoJSONItem.properties.icon = "Assets/barIcon.png";

        if (parsedBars[i].phone != null) {

            geoJSONItem.properties.phone = parsedBars[i].phone;

        }

        if (parsedBars[i]["weekday_text"] != null) {

            geoJSONItem.properties.weekday_text = parsedBars[i].weekday_text;

        }

        if (parsedBars[i].website != null) {

            geoJSONItem.properties.website = parsedBars[i].website;

        }

        geoJSONString += JSON.stringify(geoJSONItem);

        if (i < parsedBars.length - 1) {

            geoJSONString += ',';

        }
    }

    geoJSONString += ',';

    for (var i = 0; i < parsedBarRestaurants.length; i++) {

        geoJSONItem.geometry.coordinates = [parsedBarRestaurants[i]["coordinates"]["lng"], parsedBarRestaurants[i]["coordinates"]["lat"]];

        geoJSONItem.geometry.name = parsedBarRestaurants[i]["name"];

        geoJSONItem.properties.latitude = parsedBarRestaurants[i]["coordinates"]["lat"];

        geoJSONItem.properties.longitude = parsedBarRestaurants[i]["coordinates"]["lng"];

        geoJSONItem.properties.id = parsedBarRestaurants[i].id;

        geoJSONItem.properties.name = parsedBarRestaurants[i].name;

        geoJSONItem.properties.type = parsedBarRestaurants[i].type;

        geoJSONItem.properties.types = parsedBarRestaurants[i].types;

        geoJSONItem.properties.adress = parsedBarRestaurants[i].adress;

        geoJSONItem.properties.rating = Math.floor(parsedBarRestaurants[i].rating);

        geoJSONItem.properties.icon = "Assets/restaurantIcon.png";

        geoJSONString += JSON.stringify(geoJSONItem);

        if (parsedBarRestaurants[i].phone != null) {

            geoJSONItem.properties.phone = parsedBarRestaurants[i].phone;

        }

        if (parsedBarRestaurants[i]["weekday_text"] != null) {

            geoJSONItem.properties.weekday_text = parsedBarRestaurants[i].weekday_text;

        }

        if (parsedBarRestaurants[i].website != null) {

            geoJSONItem.properties.website = parsedBarRestaurants[i].website;

        }

        if (i < parsedBarRestaurants.length - 1) {

            geoJSONString += ',';

        }

    }

    geoJSONString += ',';

    for (var i = 0; i < parsedRestaurants.length; i++) {

        geoJSONItem.geometry.coordinates = [parsedRestaurants[i]["coordinates"]["lng"], parsedRestaurants[i]["coordinates"]["lat"]];

        geoJSONItem.geometry.name = parsedRestaurants[i]["name"];

        geoJSONItem.properties.latitude = parsedRestaurants[i]["coordinates"]["lat"];

        geoJSONItem.properties.longitude = parsedRestaurants[i]["coordinates"]["lng"];

        geoJSONItem.properties.id = parsedRestaurants[i].id;

        geoJSONItem.properties.name = parsedRestaurants[i].name;

        geoJSONItem.properties.type = parsedRestaurants[i].type;

        geoJSONItem.properties.types = parsedRestaurants[i].types;

        geoJSONItem.properties.adress = parsedRestaurants[i].adress;

        geoJSONItem.properties.rating = Math.floor(parsedRestaurants[i].rating);

        geoJSONItem.properties.icon = "Assets/restaurantIcon.png";

        geoJSONString += JSON.stringify(geoJSONItem);

        if (parsedRestaurants[i].phone != null) {

            geoJSONItem.properties.phone = parsedRestaurants[i].phone;

        }

        if (parsedRestaurants[i]["weekday_text"] != null) {

            geoJSONItem.properties.weekday_text = parsedRestaurants[i].weekday_text;

        }

        if (parsedRestaurants[i].website != null) {

            geoJSONItem.properties.website = parsedRestaurants[i].website;

        }

        if (i < parsedRestaurants.length - 1) {

            geoJSONString += ',';

        }

    }

    geoJSONString += ']}';

    //DEBUG DISPLAY
    //console.log(geoJSONString);

    cleanGeoJSON(geoJSONString);

}

//----------------------------------------------------------------------------------------------------------------------

function cleanGeoJSON() {

    var xobj = new XMLHttpRequest();

    xobj.overrideMimeType("application/json");

    xobj.open('GET', 'JSON/places.geojson', true);

    xobj.onreadystatechange = function () {

        if (xobj.readyState === 4 && xobj.status == "200") {

            var geoPlacesJSON = JSON.parse(xobj.responseText)["features"];

            //~ console.log(geoPlacesJSON);

            var newPlaces = [];

            var ids = [];

            var doublons = 0;

            var geoJSONItem = {

                "type": "Feature",

                "geometry": {

                    "type": "Point",

                    "coordinates": [null, null]

                },

                "properties": {

                    "adress": null,

                    "icon": null,

                    "id": null,

                    "latitude" : null,

                    "longitude" : null,

                    "name": null,

                    "opened": null,

                    "phone": null,

                    "rating": null,

                    "type": null,

                    "types": null,

                    "website": null,

                    "weekday_text": null

                }

            };

            for (var i in geoPlacesJSON) {

                geoJSONItem = geoPlacesJSON[i];

                if (ids.indexOf(geoJSONItem.properties.id) === -1) {

                    newPlaces.push(geoJSONItem);

                    ids.push(geoJSONItem.properties.id);

                } else {

                    doublons++;

                }

            }

            console.log(JSON.stringify(newPlaces));

        }

    };

    xobj.send(null);

}

//----------------------------------------------------------------------------------------------------------------------

function cleanGeoJSON(geoJSONString) {

    var geoPlacesJSON = JSON.parse(geoJSONString)["features"];

    //~ console.log(geoPlacesJSON);

    var newPlaces = [];

    var ids = [];

    var doublons = 0;

    var geoJSONItem = {

        "type": "Feature",

        "geometry": {

            "type": "Point",

            "coordinates": [null, null]

        },

        "properties": {

            "adress": null,

            "icon": null,

            "id": null,

            "latitude" : null,

            "longitude" : null,

            "name": null,

            "opened": null,

            "phone": null,

            "rating": null,

            "type": null,

            "types": null,

            "website": null,

            "weekday_text": null

        }

    };

    for (var i in geoPlacesJSON) {

        if (ids.indexOf(geoPlacesJSON[i].properties.id) === -1) {

            newPlaces.push(geoPlacesJSON[i]);

            ids.push(geoPlacesJSON[i].properties.id);

        } else {

            doublons++;

        }

    }

    console.log("{\"type\" : \"FeatureCollection\", \"features\": " + JSON.stringify(newPlaces) + "}");

}

function fusionYelpGoogle() {

    var xobj = new XMLHttpRequest();

    xobj.open('GET', 'JSON/jsonBusinessYELP.json', true);

    xobj.onreadystatechange = function () {

        if (xobj.readyState === 4 && xobj.status == "200") {

            var time = 50;

            var yelpJSON = JSON.parse(xobj.responseText);

            var i = 0;

            var geojsonBase = JSON.parse(geojsonSource);

            console.log(yelpJSON.length);

            var interval = setInterval(function () {

                console.log("Progression : " + i + " / " + yelpJSON.length);

                if ( i >= yelpJSON.length ) {

                    i = 0;

                    formatFusionBase(geojsonBase, yelpJSON);

                    clearInterval(interval);

                } else {

                    for (var j = 0; j < geojsonBase.features.length ; j++) {

                        var formattedPhone = yelpJSON[i]['display_phone'].replace('+33 ', '0');

                        var name = accent_fold(yelpJSON[i].name.toLowerCase());

                        var feature = geojsonBase.features[j].properties;

                        if( accent_fold(feature.name).indexOf(name) != -1 || feature.phone == formattedPhone ) {

                            feature.subtypes = yelpJSON[i].categories;

                            if (yelpJSON[i].phone.length != 0 && feature.phone == null) {

                                feature.phone = formattedPhone;

                            }

                            if( yelpJSON[i].price != null ) {

                                feature.price = yelpJSON[i].price;

                            }

                            yelpJSON.splice(i, 1);

                            break;

                        } else {

                            feature.subtypes = null;

                            feature.price = null;

                        }

                    }

                }

                i++;

            }, time);

        }

    };

    xobj.send(null);

}

function formatFusionBase(geojsonBase, yelpJSON) {


    for (var indice = 0 ; indice < yelpJSON.length; indice++) {

        var addedObject = {

            "type": "Feature",

            "geometry": {

                "type": "Point",

                "coordinates": [yelpJSON[indice].coordinates.longitude, yelpJSON[indice].coordinates.latitude],

                "name": yelpJSON[indice].name

            },

            "properties": {

                "adress": yelpJSON[indice].location['display_address'][0],

                "icon": null,

                "id": null,

                "latitude": yelpJSON[indice].coordinates.latitude,

                "longitude": yelpJSON[indice].coordinates.longitude,

                "name": yelpJSON[indice].name,

                "opened": null,

                "phone": yelpJSON[indice]["display_phone"],

                "price" : null,

                "rating": yelpJSON[indice].rating,

                "subtypes" : null,

                "type": "Bar-Restaurant",

                "types": null,

                "website": yelpJSON[indice].url,

                "weekday_text": null

            }

        };

        if (yelpJSON[indice].price != null) {

            addedObject.properties.price = yelpJSON[indice].price;

        }

        if( yelpJSON[indice].subtypes != null) {

            addedObject.properties.subtypes = yelpJSON[indice].subtypes;

        }

        geojsonBase.features.push(addedObject);

    }

    //console.log(JSON.stringify(geojsonBase));

    cleanPositionDoublons( JSON.stringify(geojsonBase) );

}

function cleanPositionDoublons( source ) {

    console.log("cleaning");

    var geoJSONParsed = JSON.parse(source);

    var features = geoJSONParsed.features;

    for (var i = 0; i < features.length - 1; i++){

        console.log("Cleaning doublons... " + i + " / " + features.length);

        for (var j = i + 1; j < features.length; j++) {

            if( features[i].properties.latitude == features[j].properties.latitude && features[i].properties.longitude == features[j].properties.longitude ) {

                features[i].properties.latitude += 0.000010;

                features[i].properties.longitude += 0.000010;

                features[i].geometry.coordinates[0] = features[i].properties.longitude;

                features[i].geometry.coordinates[1] = features[i].properties.latitude;

                j = features.length;

            }

        }

    }

    console.log("Done.");

    console.log(JSON.stringify(geoJSONParsed));

}

//######################################################################################################################
//#### COPYRIGHTS @ NELLY BARRET & LOUIS LE BRUN - LIFPROJET 2018 ######################################################
//######################################################################################################################